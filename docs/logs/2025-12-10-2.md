# 設計議論ログ - 2025-12-10

## 議論のサマリー

本日は仕様の詳細化を中心に議論を進めた。発散と収束のプロセスを意識し、合意形成を重視した。

## 決定事項

### 1. Redis agent_statusのスコープ外化
- 複数エージェント協調機能が後回しのため、agent_statusも不要と判断
- 将来的に複数エージェント機能を実装する際に再検討

### 2. knowledgeの保存方法
- mdファイルで管理、環境変数`KNOWLEDGE_ROOT`で保存先指定
- Obsidian vault対応、git管理可能
- ディレクトリ構造: `policies/` `lessons/` `references/` `facts/`
- YAML frontmatter（Obsidian互換）でタグ管理
- MCPツールで検索機能を提供

### 3. テーブル設計の詳細化

#### tasksテーブル
- カラム: id, title, description, status, asana_url, created_at, updated_at, completed_at
- descriptionはテンプレート化（目的、背景、完了条件、関連リソース、備考）
- タスク作成時にClaude Codeがユーザーに確認質問を行う

#### task_logsテーブル
- カラム: id, task_id, session_id, summary, purpose, result, issues, created_at
- summaryは軽い構造化（実施内容 + 使用ファイル + 差分コードブロック）
- RDBには事実のみを記録（改善提案や学びはNG）

#### decisionsテーブル
- カラム: id, matter, decision, reason, created_at
- task_idなし（タスクに紐付かない一般的な意思決定も記録）
- decided_by不要（人間とAIの合意が前提）

### 4. 技術スタックの選定
- **言語**: Python
- **MCPフレームワーク**: FastMCP
- **データベース**: PostgreSQL（素のPostgreSQL）
- **アーキテクチャ**: モノリシック構成（1つのMCPサーバー）

**選定理由**: FastMCPはMCPサーバー構築に特化、PostgreSQL/ファイル操作はPythonの得意分野、ローカル動作のためパフォーマンスは問題にならない

**却下した選択肢**: Supabase（過剰）、マイクロサービス化（複雑さを考慮し見送り）

### 5. データフローの確定
1. ユーザーがタスクを依頼
2. Claude Codeが既存タスク検索 or ユーザー確認
3. タスク未存在 → MCPでtasks作成（task_id発行）
4. プランモード → TodoWriteでタスク分解
5. 各todoを実行
6. TodoWrite(status=completed) → PostToolUseフック発火
7. Claude CodeがMCPツール呼び出し（log-completion）
8. RDBに保存

## 重要な学び・洞察

### メリット・デメリットは主観であり、理由を明記すべき
選択肢を提示する際は、「メリデメ」形式ではなく「なぜそう考えるか」の根拠を明確にする。主観的な判断には必ず理由を添える。

### 議論状況の継続的な記録の重要性
- ユーザーの発言 ≠ 決定事項
- 双方が納得して初めて決定となる
- 決定事項、提案中、却下事項を明確に区別して記録
- 次セッションでの再開を容易にするため、議論状況を明確に保つ

## 次回の議論ポイント

### 最高優先度
1. このリポジトリで仕事するときの進め方の規約（開発フロー、コミット規約等）

### 高優先度
2. MCPツールの詳細設計
3. PostToolUseフックの実装詳細
4. 既存タスク検索の方法
5. インデックス設計

## 追加議論（セッション2）

### データベース選定の再検討

**議論の発端:**
ユーザーから「PostgreSQLじゃなくてSQLiteでもいいような気がする」との提案。

**検討内容:**
- 現状のスコープ（単一エージェント、ローカル動作）ではSQLiteで十分な可能性
- PostgreSQLを選んでいた主な理由は「pgvectorが使える」だったが、ベクトルDBとしてChromaを使う意向があるため、PostgreSQLの必要性が低下

**調査実施:**
ChromaDB vs pgvectorの比較調査を実施。以下のポイントが明らかになった：

1. **Chromaの自動埋め込み機能**: OpenAI、HuggingFace等のモデルを使って、ドキュメント追加時に自動でベクトル化してくれる
2. **pgvectorの利点**: SQLとベクトル検索を組み合わせたハイブリッド検索が可能（例: tasksテーブルとknowledgeを結びつけた検索）
3. **セットアップの容易さ**: ChromaDB + SQLiteの方がPostgreSQL + pgvectorよりシンプル

**調査結果の保存:**
`.specify/memory/references/databases/chroma-vs-pgvector.md` に詳細を記録。

**結論:**
- データベース選定（SQLite vs PostgreSQL）とベクトルDB選定（ChromaDB vs pgvector）は、直近のやりたいこと完了後に議論することに決定
- 重要な判断基準: tasksとknowledgeを結びつけた検索が必要かどうか

### 今後の方針

データベース選定の議論は一旦保留し、次の最高優先度の議論（開発フロー・コミット規約等）に進む。

## 追加議論（セッション3）

### データベース選定の最終決定

**決定**: SQLiteを採用（合意済み - 2025-12-10）

**理由**:
- 現状のスコープ（単一エージェント、ローカル動作）に最適
- セットアップが簡単（ファイルベース）
- 将来的に必要になれば移行可能

### 開発フロー規約の策定

**合意内容**:

#### 1. コミット規約
- Conventional Commits形式（`feat:`, `fix:`, `docs:`, `refactor:`, `test:`, `chore:`）
- 粒度は一言で描写できる程度

#### 2. ブランチ戦略
- main直pushはpre-pushフックで防止
- 原則としてgit worktreeを使用
- ブランチ命名: `feature/<feature-name>`, `fix/<issue-name>` など

#### 3. ドキュメント管理
- **保存場所**:
  - 決定事項・設計ドキュメント: `docs/` 配下
  - 調査結果・ナレッジ: `.specify/memory/` 配下
- **更新タイミング**:
  - ナレッジ: web_search後に更新要否を判断
  - 決定事項: 認識合わせ → ユーザーOK → 記録
- **テンプレート**: 後日話し合って決定

#### 4. 決定事項の判定基準（重要な追加）

**定義**: エージェントが「これであってる？」と認識合わせを行い、ユーザーが「OK」と承認したタイミングで決定事項となる。

**認識合わせ時の必須チェック項目**:
1. **論点の網羅性**: 認識合わせの話に上がっていない論点は何か？
2. **前提の確認**: 前提の確認で漏れているものはないか？
3. **性急な結論の回避**: 十分に発散的な議論を経たか？

このプロセスにより、性急な結論を防ぎ、考慮漏れを減らすことができる。

**CLAUDE.mdへの反映**: プロジェクト固有のCLAUDE.mdに上記ルールを記載した。

## 参考
- [project-context.md](../project-context.md): プロジェクト全体のコンテキスト
- [design-insights.md](../lessons/design-insights.md): 設計における洞察・学び
- [log.md](2025-12-10.md): 以前の設計議論の詳細ログ
- [chroma-vs-pgvector.md](../references/databases/chroma-vs-pgvector.md): ChromaDBとpgvectorの比較調査
