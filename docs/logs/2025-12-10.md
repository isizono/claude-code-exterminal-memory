# Claude Code 作業記録システム設計ログ

## 概要

Claude Codeの作業記録をDBに保存し、複数エージェント間の協調と知識の永続化を実現するシステムの設計議論。

---

## 1. 初期の問い

**ユーザー:** Claude Codeに作業記録をDBに入れて欲しい。SQLite？

**検討ポイント:**
- 作業記録の具体的内容（タスク開始/終了、ファイル履歴、やり取り、エラー記録）
- 用途（振り返り、複数プロジェクト追跡、分析）
- 環境（ローカルのみ or 複数マシン/チーム共有）

**選択肢:**
- SQLite → 手軽、ローカル単一ユーザー向け
- JSON/JSONL → もっとシンプル
- DuckDB → 分析・集計多いなら
- PostgreSQL (Supabase等) → 複数マシン/チーム共有なら

---

## 2. Supabaseへの関心

**ユーザーの要望:**
- Supabaseを使ってみたい
- MCPがあるのでインターフェース作成の手間が省けそう
- 将来ベクトルDBも作りたい

**調査結果:**

### Supabase + Claude Code の事例
- Supabase MCP ServerとClaude Codeを組み合わせた開発事例あり
- Claude Code内でSupabaseの各種操作を直接実行可能
- プロジェクト作成、SQLクエリ実行、データ取得が自然言語で可能

### ベクトルDB対応
- Supabaseはpgvector拡張でベクトル検索エンジンとして使用可能
- RDBとベクトル検索の両方の機能が使える
- Pinecone、Weaviate、Faissからの移行事例あり（メタデータ管理が楽）

**注意点:**
- Supabase MCPは開発・テスト用途向け。本番データ接続は非推奨

---

## 3. ベクトルDBの実装方式

**質問:** ベクトルDB使うなら自分でAPIを用意する？

**選択肢:**

| 方法 | API自作 | 難易度 | 備考 |
|------|---------|--------|------|
| Supabase Edge Functions | 不要 | 中 | Supabase内で完結 |
| 外部でembedding生成 + MCP | 不要 | 低 | Claude Code側で生成 |
| 自前API (Next.js等) | 必要 | 高 | フル制御したい場合 |

---

## 4. システム構想の発展

**ユーザーのイメージ:**
```
┌─────────────┐
│   tasks     │  ← タスク（「〇〇機能の実装」とか）
└──────┬──────┘
       │ 1:N
       ▼
┌─────────────┐
│ task_logs   │  ← 作業記録（「△△を試した」「□□でエラー」とか）
└──────┬──────┘
       │ 抽出
       ▼
┌─────────────┐
│  documents  │  ← 永続化したい知識（「このライブラリはこう使う」とか）
│  + embedding│     ← これをベクトル化
└─────────────┘
```

**しかし関心事が違いすぎるので分離を検討:**
- 作業ログ（タスク進捗、試行錯誤）
- 永続化知識（ベクトル化してRAGに使う）

---

## 5. 複数Claude Codeの協調

**要件:** 同じタスクに複数のClaude Codeを当てたい。話し合い機能が必要。

**「話し合い」のパターン:**

- **A. 非同期の引き継ぎ型** → 今回は対象外
- **B. 同時並行で状況共有** → 必要
- **C. 意思決定の投票/合意形成** → 必要

**チャット実装の一般的方式:**

| 方式 | リアルタイム性 | 用途 |
|------|---------------|------|
| WebSocket / Pub-Sub | 高（ms単位） | Slack, Discord等 |
| RDB + ポーリング | 中（秒単位） | 簡易チャット |
| RDB + Realtime | 中〜高 | Supabaseならこれ |
| Issue/PR | 低（人間ペース） | GitHub, Linear等 |

**結論:** Claude Code同士はms単位のリアルタイム性不要。数秒〜数十秒ごとの確認で十分。

---

## 6. ハイブリッド構成の決定

**決定:**

```
┌─────────────────────────────────────────────────┐
│                   Supabase                      │
│  ・tasks（タスク管理）                           │
│  ・task_logs（作業記録・状態共有）               │
│  ・Claude Code間の「今何やってる」を同期         │
├─────────────────────────────────────────────────┤
│                  GitHub Issues                  │
│  ・設計議論・意思決定                            │
│  ・「どっちの方針でいく？」系の会話              │
│  ・人間も参加しやすい                            │
├─────────────────────────────────────────────────┤
│               将来：知識ベース                   │
│  ・永続化したいドキュメント + embedding          │
└─────────────────────────────────────────────────┘
```

---

## 7. エージェント識別の問題

**問題:** 同じタスクに複数Claude Codeを当てた場合、どうやって自分を識別する？

**事実:** Claude Codeには組み込みのセッションIDやインスタンスIDは存在しない

**対処法:**
1. 起動時にUUID生成させる（CLAUDE.mdで指示）
2. 環境変数で渡す（`AGENT_ID=agent-alpha claude`）
3. 起動時に名乗らせる（プロンプトで指定）

**しかし深掘りすると:**

セッションID追跡の意味を考えると...
- 「同じClaude Codeの連続作業」を後で追える
- でも他のClaude Codeは結局ログしか読めない
- ログが自己完結してないと意味ない
- **→ セッションIDより「ログの質」の問題**

**結論:** agent_idは「誰が書いたか」程度の意味しかない。重要なのは各ログが十分な文脈を含んでいるか。

---

## 8. next_stepsを排除すべき理由（重要な学び）

**当初の設計案:**
```sql
task_logs (
  id, task_id, agent_id,
  summary,      -- 何をしたか
  outcome,      -- 結果どうなったか
  blockers,     -- 詰まってること
  next_steps,   -- 次やるべきこと ← これが問題
  created_at
)
```

**問題点:**
```
前のClaude Codeの「next_steps」
　↓
次のClaude Codeがそれを読む
　↓
「前の奴がこう言ってたからそうしよう」
　↓
思考停止。状況変わってても気づかない
```

**結論:** 意思決定をする記録をすべきで、前回のClaude Codeの生成に頼るべきではない。

---

## 9. テーブル設計の再考

**分離すべきもの:**

| テーブル | 内容 | 性質 |
|----------|------|------|
| task_logs | やったこと、結果、事実 | 不変の記録 |
| decisions | 方針、設計判断、理由 | 意思決定の根拠 |

**設計:**
```sql
task_logs (
  id,
  task_id,
  agent_id,
  action,        -- 何をしたか
  outcome,       -- 結果（成功/失敗/発見）
  context,       -- 必要な文脈
  created_at
)

decisions (
  id,
  task_id,
  question,      -- 何を決めたか
  decision,      -- 決定内容
  rationale,     -- 理由
  decided_at,
  decided_by     -- 人間 or agent or GitHub Issue URL
)
```

**次のClaude Codeの動き方:**
1. task_logs → 事実を把握
2. decisions → 決まってる方針を確認
3. 自分で判断 → 次に何するか

前のClaude Codeの「指示」じゃなく「記録」を見て動く。

---

## 10. agent_statusの検討とRedis導入

**議論:** プランログは必要か？

**問題:** プランログ（やる予定）はnext_stepsと同じ罠になる可能性

**分解:**
- 「今やってる」宣言（状態共有）→ 必要。ただしプランよりステータスに近い
- 「次これやるべき」計画 → next_stepsと同じ問題

**agent_statusの違和感:**
ステート管理ならRDBじゃなくていい:
- Redis（揮発性OK、高速）
- ファイル（.lock的な）
- メモリ内

**結論:** Redisでステート層を分離

---

## 11. ベクトル化の目的（重要な学び）

**ユーザーの発言:**
> 例えば今わいからNEXTactionを書くべきではないって話をしたら今度逆にツッコミを入れて貰えたじゃん。そういう文脈を保存するためにベクトル化させておきたい。これがあればLLMって賢くなっていけるから

**ベクトル化すべき対象:**

```
❌ 「next_stepsカラムを作った」（単なる事実）

✅ 「next_stepsを書くべきでない。
    前のエージェントの生成に頼ると思考停止する。
    意思決定は別テーブルで管理し、
    次のエージェントは自分で判断すべき」（学び）
```

**議論のプロセスと結論の理由**をベクトル化することで、LLMが賢くなっていく。

---

## 12. 構成の確定

```
┌─────────────────────────────────────────┐
│  RDB (PostgreSQL)                       │
│  ・task_logs（実行ログ、監査用）        │
│  ・decisions（意思決定記録）            │
│  → 永続、人間も見れる                   │
├─────────────────────────────────────────┤
│  Redis                                  │
│  ・agent_status（今何してる）           │
│  → 揮発OK、高速                         │
├─────────────────────────────────────────┤
│  ベクトルDB (pgvector)                  │
│  ・議論から得られた「学び」             │
│  ・「なぜこうすべきか」の文脈           │
│  → LLMが次回以降参照して賢くなる        │
├─────────────────────────────────────────┤
│  GitHub Issues                          │
│  ・議論の場                             │
└─────────────────────────────────────────┘
```

---

## 13. 監査ログの強制

**要件:**
- 監査ログへの記入はマスト
- 永続化したい
- 人間も取れるように置いておきたい
- ToDoのタスク単位が1つ行われる度に必ず実行

**問題:**
- Claude Codeがプランを立てる
- 各ステップ完了を「自己申告」
- hookで捕まえるにしても、Claude Codeが言わないと発火しない
- 結局Claude Codeの善意に依存

**強制力のレベル:**

| 方法 | 強制力 | 備考 |
|------|--------|------|
| CLAUDE.mdで指示 | 弱 | 忘れる、無視する可能性 |
| ツール実行ごとにhook | 強 | 粒度が細かすぎる |
| カスタムツール経由を強制 | 中〜強 | 「このツール経由でしか作業できない」 |

---

## 14. 最終結論：自作APIで全部作る

**MCPの旨みが薄れた理由:**
```
当初：Supabase MCPで手軽にDB操作
　↓
今：独自のドメインロジックが必要
　・監査ログ強制
　・プラン→ステップの状態遷移
　・ベクトル化のタイミング制御
　↓
MCPの「汎用アクセス」じゃ足りない
```

**自作APIの利点:**
```
POST /tasks/{id}/steps/{step}/start
POST /tasks/{id}/steps/{step}/complete
```
→ これ叩いたら**必ず**ログ書かれる。回避不可。

ミドルウェアで監査ログ強制、バリデーション、ベクトル化トリガー、全部制御できる。

---

## 15. 最終構成

```
Claude Code
    ↓ HTTP
自作API (Next.js / Hono / FastAPI 等)
    ↓
├── PostgreSQL (タスク、ログ、decisions)
├── pgvector (学びのベクトル化)
└── Redis (agent_status)
```

---

## 未決定事項

- 言語/フレームワークの選定
- ホスティング先（Supabase Edge Functions / Vercel / VPS / ローカル）

---

## 学びのサマリー

1. **next_stepsを書くべきでない** - 前のエージェントの生成に頼ると思考停止する
2. **実行ログと意思決定は分離すべき** - 事実の記録と方針の記録は性質が違う
3. **ステート管理はRDBに向かない** - Redis等の揮発性ストアが適切
4. **MCPの汎用性 vs ドメインロジックの制御** - 要件が複雑化するとMCPの旨みが薄れる
5. **監査ログを強制するにはAPI層での制御が必要** - Claude Codeの善意に依存しない設計
6. **ベクトル化すべきは「学び」** - 事実ではなく、議論のプロセスと結論の理由